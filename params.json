{"name":"Hcp","body":"\r\nThis is a response to a [question on Stack Overflow](http://stackoverflow.com/questions/9982458/creating-a-sphere-packing-nearest-neighbor-list-from-integers) about index nearest neighbors in a hexagonal close-packed (HCP) lattice.\r\n\r\n\r\n*Caveat: Unlike the cubic lattice, there isn't a single obvious way to truncate the hexagonal close packed (HCP) structure. I've chosen a specific way of truncation that makes indexing a bit more straightforward. A different truncation scheme will lead to different indexing, and thus different relationships between nearest neighbor indices.*\r\n\r\n# Two dimensions\r\n\r\nBefore tackling the full 3d lattice, lets look at a single 2d sheet containing 25 'atoms' laid out as follows\r\n\r\n![Figure 1][fig1]\r\n\r\nNotice that alternating rows are shifted back and forth with respect to eachother. Here is one way we can number them. \r\n\r\n![FIG 2][fig2]\r\n\r\nIn this example, we have 5 rows with 5 atoms each. To be general, lets call the number of rows H, and the number of \"columns\" (atoms per row) W.\r\nThen, the index can be calculated in the same fashion as for a square lattice\r\n\r\n\r\n    index = W * row + col\r\n\r\n\r\n![FIG 3][fig3]\r\n\r\nLikewise, we can get back from index to row and column using truncating division and the modulo operator\r\n\r\n\r\n    row = index / W\r\n    col = index % W\r\n\r\n\r\n## Neighbors\r\n\r\nNow, lets look at the nearest neighbors. First, ignoring edges, we see that each atom has six nearest neighbors. For atom i, two of the neighbors are easy, namely i-1 and i+1. We can also notice that i+W and i-W are always neighbors of i. The last two are a little trickier, since they depend on the row i is in. Consider atom 7. It is neighbors with atoms 1 and 11, which are i-W-1 and i+W-1. But, atom 12 is neighbors with 8 and 18 (i-W+1 and i+W+1). For atoms in an odd row, we have to subtract one, while for atoms in an even row we need to add one. So, for atoms *in the bulk*, we would have\r\n\r\n\r\n    def neighbors2d(i, W):\r\n      row = i / W\r\n      return [\r\n              i+1,\r\n              i-1,\r\n              i+W,\r\n              i-W,\r\n              i+W+(-1)**row,\r\n              i-W+(-1)**row,\r\n             ]\r\n\r\n\r\nAfter fully accounting for edges, we have\r\n\r\n\r\n    def neighbors2d(i, W, H):\r\n      row = i / W\r\n      col = i % W\r\n\r\n      r = -1 if row % 2 else 1 # r = (-1)**row\r\n\r\n      nbors = []\r\n\r\n      if col != W-1:\r\n        nbors.append(i+1)\r\n      if col != 0:\r\n        nbors.append(i-1)\r\n      if row != H-1:\r\n        nbors.append(i+W)\r\n      if row != 0:\r\n        nbors.append(i-W)\r\n      if (col != 0 or r > 0) and (col != W-1 or r < 0):\r\n        if row != H-1:\r\n          nbors.append(i+W+r)\r\n        if row != 0:\r\n          nbors.append(i-W+r)\r\n\r\n      return nbors\r\n\r\n\r\n# Three dimensions\r\n\r\nWhen we add a second sheet, we have a choice of how to offset it. I chose the following, which is most consistent with how we offset rows.\r\n\r\n![FIG 4][fig4]\r\n\r\nBy numbering the planes (starting with 0), we again have a simple relation between atom index and (col,row,plane) coordinates.\r\n\r\n\r\n    index = plane * W * H + row * W + col\r\n    plane = index / (W*H)\r\n    plane_index = index % (W*H)\r\n    row = plane_index / W\r\n    col = plane_index % W\r\n\r\n\r\n![FIG 5][fig5]\r\n\r\nSimilar to how we had to account for the alternating shift in rows above, we now have to account for the alternating shift in sheets. But, this can be done in a very similar fashion. I found that it helped to reduce things to `plane_index` to figure out the relationships between neighbors, and how they depended on whether the row and plane were even or odd. The following images demonstrate this.\r\n\r\n![Figure 6][fig6b]\r\n\r\nFinally, after again accounting for edges (which is a bit more complex this time), we have\r\n\r\n\r\n    def neighbors(i, W, H, D):\r\n      A = W * H\r\n\r\n      plane = i / A\r\n      plane_index = i % A\r\n      row = plane_index / W\r\n      col = plane_index % W\r\n\r\n      r = -1 if row % 2 else 1   # (-1)**row\r\n      p = -1 if plane % 2 else 1 # (-1)**plane\r\n\r\n      nbors = []\r\n\r\n      # first include neighbors in same plane\r\n      if col != W-1: nbors.append(i+1)\r\n      if col != 0:   nbors.append(i-1)\r\n      if row != H-1: nbors.append(i+W)\r\n      if row != 0:   nbors.append(i-W)\r\n      if (col != 0 or r > 0) and (col != W-1 or r < 0):\r\n        if row != H-1: nbors.append(i+W+r)\r\n        if row != 0:   nbors.append(i-W+r)\r\n\r\n      # now add neighbors from other planes\r\n      if plane != D-1: nbors.append(i+A)\r\n      if plane != 0:   nbors.append(i-A)\r\n\r\n      if (col != 0 or p < 0) and (col != W-1 or p > 0):\r\n        if plane != D-1: nbors.append(i+A-p)\r\n        if plane != 0:   nbors.append(i-A-p)\r\n\r\n      if ((col != W - 1 or p > 0 or r < 0) and\r\n          (col != 0 or p < 0 or r > 0) and\r\n          (row != H-1 or p < 0) and\r\n          (row != 0 or p > 0)):\r\n        if plane != D-1:\r\n          nbors.append(i + A + p*W + (r-p)/2) #10\r\n        if plane != 0:\r\n          nbors.append(i - A + p*W + (r-p)/2) #11\r\n\r\n      return nbors\r\n\r\n\r\nTo make sure I got the logic correct, I used the following test while writing the above function\r\n\r\n\r\n    def test_neighbors():\r\n      n = lambda i: set(neighbors(i, 5, 5, 5))\r\n\r\n      # test bottom layer\r\n      assert n(0) == set([1,5,6,25,30])\r\n      assert n(2) == set([1,3,7,8,26,27,32])\r\n      assert n(4) == set([3,9,28,29,34])\r\n      assert n(5) == set([0,6,10,30])\r\n      assert n(9) == set([3,4,8,13,14,33,34,38])\r\n      assert n(20) == set([15,16,21,45])\r\n      assert n(21) == set([16,17,20,22,45,46])\r\n      assert n(24) == set([19,23,48,49])\r\n\r\n      # test second layer\r\n      assert n(25) == set([0,1,26,30,31,50,51])\r\n      assert n(34) == set([4,9,28,29,33,38,39,54,59])\r\n      assert n(36) == set([7,11,12,31,32,35,37,41,42,57,61,62])\r\n      assert n(49) == set([24,44,48,74])\r\n\r\n\r\nNote that the test doesn't cover all of the unique types of sites, so, there may still be a corner case somewhere that is wrong. I'll leave checking that as an exercise to the reader.\r\n\r\n[fig1]: http://i.imgur.com/tRXUR.png\r\n[fig2]: http://i.imgur.com/gymIl.png\r\n[fig3]: http://i.imgur.com/6phKf.png\r\n[fig4]: http://i.imgur.com/Cos70.png\r\n[fig5]: http://i.imgur.com/zi2oi.png\r\n[fig6]: http://i.imgur.com/r9MLs.png\r\n[fig6b]: http://i.imgur.com/foaLV.png\r\n[fig7]: http://i.imgur.com/tFu47.png\r\n","tagline":"Hexagonal Close Packed Indexing","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}